package services

import java.util.concurrent.atomic.AtomicInteger
import javax.inject.Inject

import akka.NotUsed
import akka.stream.scaladsl.Source
import models._
import org.joda.time.DateTime
import repositories.{UserRepository, JdbcProfileProvider, CommentsRepository}
import repositories.Models.CommentDbModel

import scala.concurrent.{ExecutionContext, Future}

class CommentService @Inject()(
        eventPublisher: EventPublisher,
        commentsRepository: CommentsRepository,
        userRepository: UserRepository,
        jdbc: JdbcProfileProvider)(implicit exec: ExecutionContext) {

  val commentCount  = new AtomicInteger(5)
  var comments = Seq(
    Comment(id = CommentId(0), userId = UserId("1"), username="Vasia", gitHubId = GitHubRepositoryId("play", "play"), text = "Some nice message", createdOn = DateTime.now()),
    Comment(id = CommentId(1), userId = UserId("2"), username="Vadimka", gitHubId = GitHubRepositoryId("spring", "spring"), text = "Some message", createdOn = DateTime.now()),
    Comment(id = CommentId(2), userId = UserId("3"), username="Tajana", gitHubId = GitHubRepositoryId("netflix", "hystrix"), text = "OMG", createdOn = DateTime.now()))

  val OldestToNewestOrdering: Ordering[DateTime] = Ordering.fromLessThan(_ isBefore _)

  //Slick implicits
  import jdbc.provider._
  import jdbc.provider.driver.api._


  def getRepositoryComments(repoId: GitHubRepositoryId): Future[Seq[Comment]] = db.run {
    commentsRepository.getForRepository(repoId)
      .map(comments => comments.map(toComment))
  }

  def getRepositoryCommentsSource(repoId: GitHubRepositoryId): Source[Seq[Comment], NotUsed] = eventPublisher.subscribe
    .filter { case event: NewCommentEvent => event.gitHubId == repoId }
    .mapAsync(1) { _ => getRepositoryComments(repoId) }

  def create(repo: GitHubRepositoryId, newComment: NewComment): Future[Comment] = {
    val comment = CommentDbModel(
      id = 0, //autogenerated in insert anyway
      user = newComment.userId.value.toLong,
      repositoryOwner = repo.owner,
      repositoryName = repo.name,
      comment = newComment.text,
      createdOn = DateTime.now)

    db.run {
      commentsRepository.insert(comment)
      .map(generatedId => toComment(comment))
      .flatMap(c =>
        userRepository.getById(c.userId.value)
          .flatMap {
            user => addUsernameInfo(c, user) match {
              case Some(v) => DBIO.successful(v)
              case None => DBIO.failed(new RuntimeException(s"User with id ${c.userId.value} not exits"))
            }
          })
      .map(comment => PublishableResult(comment, NewCommentEvent(repo, comment.id)))
      .map(eventPublisher.publishUnwrap)
    }
  }

  private def addUsernameInfo(comment: Comment, userOption: Option[User]): Option[Comment] = {
    userOption.map(u => comment.copy(username = u.username))
  }

  private def toComment(commentDbModel: CommentDbModel): Comment = {
    Comment(
      CommentId(commentDbModel.id),
      UserId(commentDbModel.user.toString),
      commentDbModel.username,
      GitHubRepositoryId(commentDbModel.repositoryOwner, commentDbModel.repositoryName),
      commentDbModel.comment,
      commentDbModel.createdOn)
  }
}

package services

import java.util.concurrent.atomic.AtomicInteger
import javax.inject.Inject

import akka.NotUsed
import akka.stream.scaladsl.Source
import models._
import org.joda.time.DateTime
import repositories.{UserRepository, JdbcProfileProvider, CommentsRepository}
import repositories.Models.CommentDbModel

import scala.concurrent.{ExecutionContext, Future}

class CommentService @Inject()(
        eventPublisher: EventPublisher,
        commentsRepository: CommentsRepository,
        userRepository: UserRepository,
        jdbc: JdbcProfileProvider)(implicit exec: ExecutionContext) {

  /*val commentCount  = new AtomicInteger(5)
  var comments = Seq(
    Comment(id = CommentId(0), userId = UserId("1"), username="Vasia", gitHubId = GitHubRepositoryId("play", "play"), text = "Some nice message", createdOn = DateTime.now()),
    Comment(id = CommentId(1), userId = UserId("2"), username="Vadimka", gitHubId = GitHubRepositoryId("spring", "spring"), text = "Some message", createdOn = DateTime.now()),
    Comment(id = CommentId(2), userId = UserId("3"), username="Tajana", gitHubId = GitHubRepositoryId("netflix", "hystrix"), text = "OMG", createdOn = DateTime.now()))
*/
  //Slick implicits for db.run
  import jdbc.provider._
  import jdbc.provider.driver.api._

  def getRepositoryComments(repoId: GitHubRepositoryId): Future[Seq[Comment]] = db.run {
    commentsRepository.getForRepository(repoId).map { comments => comments
      .map(comment => toApiComment(comment._1, comment._2))
    }
  }

  def create(repo: GitHubRepositoryId, newComment: NewComment): Future[Comment] = db.run {
    commentsRepository.insert(fromNewCommentToDb(repo, newComment))
      .flatMap(c => userRepository.getById(c.user).flatMap {
        case Some(u) => DBIO.successful(toApiComment(c, u))
        case None => DBIO.failed(new RuntimeException(s"User with id ${c.user} not exits"))
      })
      .map(comment => PublishableResult(comment, NewCommentEvent(repo, comment.id)))
      .map(eventPublisher.publishEventsAndReturnResult)
  }

  private def toApiComment(commentDbModel: CommentDbModel, user: User): Comment = {
    Comment(
      CommentId(commentDbModel.id),
      UserId(commentDbModel.user),
      user.username,
      GitHubRepositoryId(commentDbModel.repositoryOwner, commentDbModel.repositoryName),
      commentDbModel.comment,
      commentDbModel.createdOn)
  }

  private def fromNewCommentToDb(repo: GitHubRepositoryId, newComment: NewComment) = {
    CommentDbModel(
      id = 0, //autogenerated in insert anyway
      user = newComment.userId.value,
      repositoryOwner = repo.owner,
      repositoryName = repo.name,
      comment = newComment.text,
      createdOn = DateTime.now)
  }

  def getRepositoryCommentsSource(repoId: GitHubRepositoryId): Source[Seq[Comment], NotUsed] = eventPublisher.subscribe
    .filter { case event: NewCommentEvent => event.gitHubId == repoId }
    .mapAsync(1) { _ => getRepositoryComments(repoId) }

}
